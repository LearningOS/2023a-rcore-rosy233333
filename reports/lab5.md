# 第五次实验报告

## 学习内容

线程并发的实现方式，以及死锁的预防

## chapter8练习的实现功能总结

本练习在PCB中添加了开启死锁检测的标志`deadlock_detect`，并实现了使用银行家算法预防死锁的数据结构`DdStruct`，在PCB中分别添加了管理互斥锁和管理信号量的两个`DdStruct`对象。

本练习实现了设置是否开启死锁检测的系统调用`sys_enable_deadlock_detect`，并且在互斥锁和信号量的相关系统调用中增加了更新`DdStruct`和检测死锁的代码。

## 问答作业

### 1. 在我们的多线程实现中，当主线程 (即 0 号线程) 退出时，视为整个进程退出， 此时需要结束该进程管理的所有线程并回收其资源。 - 需要回收的资源有哪些？ - 其他线程的 TaskControlBlock 可能在哪些位置被引用，分别是否需要回收，为什么？

回收的资源：打开的文件、映射的虚拟内存、申请的信号量与互斥锁、PCB和TCB对象等。

TCB可能在CPU的等待队列、互斥锁或信号量的等待队列中。需要回收。

### 2. 对比以下两种 Mutex.unlock 的实现，二者有什么区别？这些区别可能会导致什么问题？

第一种先解锁互斥锁，再从等待队列中唤醒线程。第二种直接从等待队列中唤醒线程，不解锁互斥锁。

采用第一种方式，可能在被唤醒的线程执行之前，互斥锁又会被其它线程获取，导致同时有两个线程在临界区中执行。若采用第二种方式，则没有这个问题。

## 荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

    与微信群内讲师-hky等人讨论过如何建立需求矩阵。

2. 此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

    无

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。

## 对实验的看法

实验要求中说“不要求合并之前的实验内容”，但不完全如此。测例中使用了userlib中的`wait`函数，其使用了`get_time`系统调用。而在实验原有的代码中，`get_time`并没有实现，需要合并之前的内容来实现。

在我的实验过程中，`get_time`未实现导致的现象为：QEMU久久不结束，且查看结果，发现deadlock_sem1和deadlock_sem2不通过。因此我以为是我的死锁检测代码有问题，出现了死锁，但排查了很久也没发现问题。后来发现这两个测例都使用了`wait`函数。而其使用了`get_time`系统调用，才找到问题的真正所在。

因此我建议，在实验要求中提示用户需要实现`get_time`系统调用，否则用户很可能被“不要求合并之前的实验内容”的表述误导。